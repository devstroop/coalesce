// Additional system language generators for C and Go

use coalesce_core::{Generator, Language, UIRNode, NodeType, ExpressionType, StatementType, Result};

pub struct CGenerator;

impl Generator for CGenerator {
    fn target_language(&self) -> Language {
        Language::C
    }
    
    fn generate(&self, uir: &UIRNode) -> Result<String> {
        match &uir.node_type {
            NodeType::Module => {
                let mut code = String::from("// Generated by Coalesce\n#include <stdio.h>\n\n");
                
                for child in &uir.children {
                    code.push_str(&self.generate(child)?);
                    code.push('\n');
                }
                
                Ok(code)
            }
            NodeType::Function => {
                self.generate_function(uir)
            }
            NodeType::Variable => {
                Ok(uir.name.as_deref().unwrap_or("unknown_var").to_string())
            }
            NodeType::Statement(StatementType::Return) => {
                self.generate_return_statement(uir)
            }
            NodeType::Expression(ExpressionType::Arithmetic) => {
                self.generate_arithmetic_expression(uir)
            }
            NodeType::Expression(ExpressionType::Variable) => {
                Ok(uir.name.as_deref().unwrap_or("unknown").to_string())
            }
            NodeType::Expression(ExpressionType::Literal) => {
                if let Some(original) = uir.metadata.annotations.get("original_text") {
                    if let Some(text) = original.as_str() {
                        Ok(text.to_string())
                    } else {
                        Ok("0".to_string())
                    }
                } else {
                    Ok("0".to_string())
                }
            }
            _ => {
                Ok("/* TODO: Implement UIR node generation */\n".to_string())
            }
        }
    }
}

impl CGenerator {
    fn generate_function(&self, uir: &UIRNode) -> Result<String> {
        let func_name = uir.name.as_deref().unwrap_or("generated_function");
        
        let mut parameters = Vec::new();
        let mut statements = Vec::new();
        
        for child in &uir.children {
            match &child.node_type {
                NodeType::Variable => {
                    if let Some(param_name) = &child.name {
                        parameters.push(format!("int {}", param_name)); // Default to int type
                    }
                }
                NodeType::Statement(_) => {
                    statements.push(child);
                }
                _ => {
                    statements.push(child);
                }
            }
        }
        
        let params_str = parameters.join(", ");
        
        let body = if statements.is_empty() {
            "    /* Empty function */".to_string()
        } else {
            let mut body_code = String::new();
            for stmt in &statements {
                let stmt_code = self.generate(stmt)?;
                for line in stmt_code.lines() {
                    if !line.trim().is_empty() {
                        body_code.push_str(&format!("    {};\n", line.trim()));
                    }
                }
            }
            body_code.trim_end().to_string()
        };
        
        let return_type = if statements.iter().any(|s| matches!(s.node_type, NodeType::Statement(StatementType::Return))) {
            "int" // Simple default return type
        } else {
            "void"
        };
        
        Ok(format!("{} {}({}) {{\n{}\n}}", return_type, func_name, params_str, body))
    }
    
    fn generate_return_statement(&self, uir: &UIRNode) -> Result<String> {
        if uir.children.is_empty() {
            Ok("return".to_string())
        } else {
            let expr_code = self.generate(&uir.children[0])?;
            Ok(format!("return {}", expr_code.trim()))
        }
    }
    
    fn generate_arithmetic_expression(&self, uir: &UIRNode) -> Result<String> {
        if uir.children.len() == 2 {
            let left = self.generate(&uir.children[0])?.trim().to_string();
            let right = self.generate(&uir.children[1])?.trim().to_string();
            
            let operator = if let Some(original) = uir.metadata.annotations.get("original_text") {
                if let Some(text) = original.as_str() {
                    if text.contains(" + ") {
                        " + "
                    } else if text.contains(" - ") {
                        " - "
                    } else if text.contains(" * ") {
                        " * "
                    } else if text.contains(" / ") {
                        " / "
                    } else {
                        " + "
                    }
                } else {
                    " + "
                }
            } else {
                " + "
            };
            
            Ok(format!("{}{}{}", left, operator, right))
        } else {
            Ok("unknown_expression".to_string())
        }
    }
}

pub struct GoGenerator;

impl Generator for GoGenerator {
    fn target_language(&self) -> Language {
        Language::Go
    }
    
    fn generate(&self, uir: &UIRNode) -> Result<String> {
        match &uir.node_type {
            NodeType::Module => {
                let mut code = String::from("// Generated by Coalesce\npackage main\n\n");
                
                for child in &uir.children {
                    code.push_str(&self.generate(child)?);
                    code.push('\n');
                }
                
                Ok(code)
            }
            NodeType::Function => {
                self.generate_function(uir)
            }
            NodeType::Variable => {
                Ok(uir.name.as_deref().unwrap_or("unknownVar").to_string())
            }
            NodeType::Statement(StatementType::Return) => {
                self.generate_return_statement(uir)
            }
            NodeType::Expression(ExpressionType::Arithmetic) => {
                self.generate_arithmetic_expression(uir)
            }
            NodeType::Expression(ExpressionType::Variable) => {
                Ok(uir.name.as_deref().unwrap_or("unknown").to_string())
            }
            NodeType::Expression(ExpressionType::Literal) => {
                if let Some(original) = uir.metadata.annotations.get("original_text") {
                    if let Some(text) = original.as_str() {
                        Ok(text.to_string())
                    } else {
                        Ok("0".to_string())
                    }
                } else {
                    Ok("0".to_string())
                }
            }
            _ => {
                Ok("// TODO: Implement UIR node generation\n".to_string())
            }
        }
    }
}

impl GoGenerator {
    fn generate_function(&self, uir: &UIRNode) -> Result<String> {
        let func_name = uir.name.as_deref().unwrap_or("generatedFunction");
        
        let mut parameters = Vec::new();
        let mut statements = Vec::new();
        
        for child in &uir.children {
            match &child.node_type {
                NodeType::Variable => {
                    if let Some(param_name) = &child.name {
                        parameters.push(format!("{} int", param_name)); // Default to int type
                    }
                }
                NodeType::Statement(_) => {
                    statements.push(child);
                }
                _ => {
                    statements.push(child);
                }
            }
        }
        
        let params_str = parameters.join(", ");
        
        let body = if statements.is_empty() {
            "    // Empty function".to_string()
        } else {
            let mut body_code = String::new();
            for stmt in &statements {
                let stmt_code = self.generate(stmt)?;
                for line in stmt_code.lines() {
                    if !line.trim().is_empty() {
                        body_code.push_str(&format!("    {}\n", line.trim()));
                    }
                }
            }
            body_code.trim_end().to_string()
        };
        
        let return_type = if statements.iter().any(|s| matches!(s.node_type, NodeType::Statement(StatementType::Return))) {
            " int" // Simple default return type
        } else {
            ""
        };
        
        Ok(format!("func {}({}){} {{\n{}\n}}", func_name, params_str, return_type, body))
    }
    
    fn generate_return_statement(&self, uir: &UIRNode) -> Result<String> {
        if uir.children.is_empty() {
            Ok("return".to_string())
        } else {
            let expr_code = self.generate(&uir.children[0])?;
            Ok(format!("return {}", expr_code.trim()))
        }
    }
    
    fn generate_arithmetic_expression(&self, uir: &UIRNode) -> Result<String> {
        if uir.children.len() == 2 {
            let left = self.generate(&uir.children[0])?.trim().to_string();
            let right = self.generate(&uir.children[1])?.trim().to_string();
            
            let operator = if let Some(original) = uir.metadata.annotations.get("original_text") {
                if let Some(text) = original.as_str() {
                    if text.contains(" + ") {
                        " + "
                    } else if text.contains(" - ") {
                        " - "
                    } else if text.contains(" * ") {
                        " * "
                    } else if text.contains(" / ") {
                        " / "
                    } else {
                        " + "
                    }
                } else {
                    " + "
                }
            } else {
                " + "
            };
            
            Ok(format!("{}{}{}", left, operator, right))
        } else {
            Ok("unknown_expression".to_string())
        }
    }
}

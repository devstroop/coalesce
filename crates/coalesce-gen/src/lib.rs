use coalesce_core::{Generator, Language, UIRNode, NodeType, ExpressionType, StatementType, Result};

mod system_generators;

pub use system_generators::{CGenerator, GoGenerator};

pub struct PythonGenerator;

impl Generator for PythonGenerator {
    fn target_language(&self) -> Language {
        Language::Python
    }
    
    fn generate(&self, uir: &UIRNode) -> Result<String> {
        match &uir.node_type {
            NodeType::Module => {
                let mut code = String::from("# Generated by Coalesce\n\n");
                
                for child in &uir.children {
                    code.push_str(&self.generate(child)?);
                    code.push('\n');
                }
                
                Ok(code)
            }
            NodeType::Function => {
                self.generate_function(uir)
            }
            NodeType::Class => {
                self.generate_class(uir)
            }
            NodeType::Variable => {
                // For function parameters and variable references
                Ok(uir.name.as_deref().unwrap_or("unknown_var").to_string())
            }
            NodeType::Statement(StatementType::Return) => {
                self.generate_return_statement(uir)
            }
            NodeType::Expression(ExpressionType::Arithmetic) => {
                self.generate_arithmetic_expression(uir)
            }
            NodeType::Expression(ExpressionType::Variable) => {
                Ok(uir.name.as_deref().unwrap_or("unknown").to_string())
            }
            NodeType::Expression(ExpressionType::Literal) => {
                // Extract literal value from original text
                if let Some(original) = uir.metadata.annotations.get("original_text") {
                    if let Some(text) = original.as_str() {
                        Ok(text.to_string())
                    } else {
                        Ok("0".to_string()) // default literal
                    }
                } else {
                    Ok("0".to_string()) // default literal
                }
            }
            _ => {
                Ok("# TODO: Implement UIR node generation\n".to_string())
            }
        }
    }
}

impl PythonGenerator {
    fn generate_function(&self, uir: &UIRNode) -> Result<String> {
        let func_name = uir.name.as_deref().unwrap_or("generated_function");
        
        // Extract parameters from children (Variable nodes that are direct children)
        let mut parameters = Vec::new();
        let mut statements = Vec::new();
        
        for child in &uir.children {
            match &child.node_type {
                NodeType::Variable => {
                    // This is a parameter
                    if let Some(param_name) = &child.name {
                        parameters.push(param_name.clone());
                    }
                }
                NodeType::Statement(_) => {
                    // This is a statement in the function body
                    statements.push(child);
                }
                _ => {
                    // Other types might be statements too
                    statements.push(child);
                }
            }
        }
        
        let params_str = parameters.join(", ");
        
        // Generate function body
        let body = if statements.is_empty() {
            "    pass".to_string()
        } else {
            let mut body_code = String::new();
            for stmt in statements {
                let stmt_code = self.generate(stmt)?;
                // Add proper indentation
                for line in stmt_code.lines() {
                    if !line.trim().is_empty() {
                        body_code.push_str(&format!("    {}\n", line));
                    }
                }
            }
            body_code.trim_end().to_string()
        };
        
        Ok(format!("def {}({}):\n{}", func_name, params_str, body))
    }
    
    fn generate_class(&self, uir: &UIRNode) -> Result<String> {
        let class_name = uir.name.as_deref().unwrap_or("GeneratedClass");
        
        let mut methods = Vec::new();
        let mut class_vars = Vec::new();
        
        for child in &uir.children {
            match &child.node_type {
                NodeType::Function => {
                    let method_code = self.generate_function(child)?;
                    // Indent the method
                    let indented_method = method_code.lines()
                        .map(|line| if line.trim().is_empty() { line.to_string() } else { format!("    {}", line) })
                        .collect::<Vec<_>>()
                        .join("\n");
                    methods.push(indented_method);
                }
                NodeType::Variable => {
                    if let Some(var_name) = &child.name {
                        class_vars.push(format!("    {} = None", var_name));
                    }
                }
                _ => {}
            }
        }
        
        let mut class_body = String::new();
        
        if class_vars.is_empty() && methods.is_empty() {
            class_body.push_str("    pass");
        } else {
            if !class_vars.is_empty() {
                class_body.push_str(&class_vars.join("\n"));
                if !methods.is_empty() {
                    class_body.push_str("\n\n");
                }
            }
            
            if !methods.is_empty() {
                class_body.push_str(&methods.join("\n\n"));
            }
        }
        
        Ok(format!("class {}:\n{}", class_name, class_body))
    }
    
    fn generate_return_statement(&self, uir: &UIRNode) -> Result<String> {
        if uir.children.is_empty() {
            Ok("return".to_string())
        } else {
            let expr_code = self.generate(&uir.children[0])?;
            Ok(format!("return {}", expr_code.trim()))
        }
    }
    
    fn generate_arithmetic_expression(&self, uir: &UIRNode) -> Result<String> {
        // For binary expressions, we expect two operands
        if uir.children.len() == 2 {
            let left = self.generate(&uir.children[0])?.trim().to_string();
            let right = self.generate(&uir.children[1])?.trim().to_string();
            
            // Extract the operator from the original text if available
            let operator = if let Some(original) = uir.metadata.annotations.get("original_text") {
                if let Some(text) = original.as_str() {
                    // Simple heuristic: if it contains "+", use "+"
                    if text.contains(" + ") {
                        " + "
                    } else if text.contains(" - ") {
                        " - "
                    } else if text.contains(" * ") {
                        " * "
                    } else if text.contains(" / ") {
                        " / "
                    } else {
                        " + " // default
                    }
                } else {
                    " + " // default
                }
            } else {
                " + " // default
            };
            
            Ok(format!("{}{}{}", left, operator, right))
        } else {
            Ok("unknown_expression".to_string())
        }
    }
}

pub struct RustGenerator;

impl Generator for RustGenerator {
    fn target_language(&self) -> Language {
        Language::Rust
    }
    
    fn generate(&self, uir: &UIRNode) -> Result<String> {
        match &uir.node_type {
            NodeType::Module => {
                let mut code = String::from("// Generated by Coalesce\n\n");
                
                for child in &uir.children {
                    code.push_str(&self.generate(child)?);
                    code.push('\n');
                }
                
                Ok(code)
            }
            NodeType::Function => {
                self.generate_function(uir)
            }
            NodeType::Variable => {
                Ok(uir.name.as_deref().unwrap_or("unknown_var").to_string())
            }
            NodeType::Statement(StatementType::Return) => {
                self.generate_return_statement(uir)
            }
            NodeType::Expression(ExpressionType::Arithmetic) => {
                self.generate_arithmetic_expression(uir)
            }
            NodeType::Expression(ExpressionType::Variable) => {
                Ok(uir.name.as_deref().unwrap_or("unknown").to_string())
            }
            NodeType::Expression(ExpressionType::Literal) => {
                // Extract literal value from original text
                if let Some(original) = uir.metadata.annotations.get("original_text") {
                    if let Some(text) = original.as_str() {
                        Ok(text.to_string())
                    } else {
                        Ok("0".to_string()) // default literal
                    }
                } else {
                    Ok("0".to_string()) // default literal
                }
            }
            _ => {
                Ok("// TODO: Implement UIR node generation\n".to_string())
            }
        }
    }
}

impl RustGenerator {
    fn generate_function(&self, uir: &UIRNode) -> Result<String> {
        let func_name = uir.name.as_deref().unwrap_or("generated_function");
        
        // Extract parameters from children
        let mut parameters = Vec::new();
        let mut statements = Vec::new();
        
        for child in &uir.children {
            match &child.node_type {
                NodeType::Variable => {
                    if let Some(param_name) = &child.name {
                        // In Rust, we need to add basic type annotations
                        parameters.push(format!("{}: i32", param_name)); // Simple default type
                    }
                }
                NodeType::Statement(_) => {
                    statements.push(child);
                }
                _ => {
                    statements.push(child);
                }
            }
        }
        
        let params_str = parameters.join(", ");
        
        // Generate function body
        let body = if statements.is_empty() {
            "    // Empty function".to_string()
        } else {
            let mut body_code = String::new();
            for (i, stmt) in statements.iter().enumerate() {
                let stmt_code = self.generate(stmt)?;
                let is_last = i == statements.len() - 1;
                
                // In Rust, the last statement can be an expression (no semicolon)
                // if it's a return statement
                if is_last && matches!(stmt.node_type, NodeType::Statement(StatementType::Return)) {
                    // Convert "return expr" to just "expr" for Rust
                    let expr_code = if stmt_code.trim().starts_with("return ") {
                        stmt_code.trim().strip_prefix("return ").unwrap_or(stmt_code.trim())
                    } else {
                        stmt_code.trim()
                    };
                    body_code.push_str(&format!("    {}\n", expr_code));
                } else {
                    for line in stmt_code.lines() {
                        if !line.trim().is_empty() {
                            body_code.push_str(&format!("    {};\n", line.trim()));
                        }
                    }
                }
            }
            body_code.trim_end().to_string()
        };
        
        // Determine return type based on content (simple heuristic)
        let return_type = if statements.iter().any(|s| matches!(s.node_type, NodeType::Statement(StatementType::Return))) {
            " -> i32" // Simple default return type
        } else {
            ""
        };
        
        Ok(format!("fn {}({}){} {{\n{}\n}}", func_name, params_str, return_type, body))
    }
    
    fn generate_return_statement(&self, uir: &UIRNode) -> Result<String> {
        if uir.children.is_empty() {
            Ok("return".to_string())
        } else {
            let expr_code = self.generate(&uir.children[0])?;
            Ok(format!("return {}", expr_code.trim()))
        }
    }
    
    fn generate_arithmetic_expression(&self, uir: &UIRNode) -> Result<String> {
        // Same logic as Python generator
        if uir.children.len() == 2 {
            let left = self.generate(&uir.children[0])?.trim().to_string();
            let right = self.generate(&uir.children[1])?.trim().to_string();
            
            let operator = if let Some(original) = uir.metadata.annotations.get("original_text") {
                if let Some(text) = original.as_str() {
                    if text.contains(" + ") {
                        " + "
                    } else if text.contains(" - ") {
                        " - "
                    } else if text.contains(" * ") {
                        " * "
                    } else if text.contains(" / ") {
                        " / "
                    } else {
                        " + "
                    }
                } else {
                    " + "
                }
            } else {
                " + "
            };
            
            Ok(format!("{}{}{}", left, operator, right))
        } else {
            Ok("unknown_expression".to_string())
        }
    }
}
